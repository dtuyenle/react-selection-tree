import React, {Component} from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import color from './../color';
import CheckBox from './../CheckBox';
import Radio from './../Radio';
import BreadCrum from './../BreadCrum';
import ToolTip from './../ToolTip';
import {List} from 'react-virtualized';
import {debounce} from './../utils';

const removeDuplicates = (myArr, prop) => {
  return myArr.filter((obj, pos, arr) => {
    return arr.map(mapObj => mapObj[prop]).indexOf(obj[prop]) === pos;
  });
};

const MozartCheckboxLabelLevelDown = styled.span`
  span {
    color: ${color.blue_accent};
    margin: 1px 10px 0 0 !important;
  }
`;

const MozartfilterCheckboxContainer = styled.div`
  margin-top: 5px;
  width: 98%;
  max-height: 280px;
  overflow: auto;
  span {
    margin: 0;
    font-weight: 400;
  }
`;

const ClearAll = styled.div`
  margin-top: 10px;
  margin-left: 10px;
  color: ${color.t12};
  cursor: pointer;
  width: 60px;
`;

const MozartFilterSearch = styled.div`
  border-radius: 5px;
  border: none;
  text-align: left;
  display: flex;
  padding-right: 15%;
  justify-content: flex-end;
  &:after {
    content: "";
    display: table;
    clear: both;
  }
  span {
    background: ${color.blue_main};
    color: ${color.white};
    border: 1px ${color.blue_accent} solid;
    border-right: none;
    padding: 0.6em;
    border-radius: 0 5px 5px 0;
    border-bottom: 2px #715AFF solid;
  }
  input {
    font-size: 0.8em;
    padding: 0.8em;
    border: 1px ${color.blue_accent} solid;
    border-radius: 5px 0 0 5px;
    width: 100%;
  }
`;

const MozartCheckboxCustom = styled.div`
  font-size: 0.8em;
  margin: 1em 0;
  margin-bottom: -20px;

  label:before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 8px;
    height: 8px;
    border: 1px solid #ddd;
    background: #fff;
  }
`;

const BREADCRUMS = styled.div`
  margin: 10px;
  text-align: left;
`;

export default class InputBox extends Component {
  static propTypes = {
    /** qa attribute */
    testId: PropTypes.string,
    name: PropTypes.string.isRequired,
    filter: PropTypes.object.isRequired,
    excludeSelect: PropTypes.array,
    /** if none tooltip is hidden. Available options: right/left/top/bottom */
    toolTipPlacement: PropTypes.string,

    customName: PropTypes.string,
    customValue: PropTypes.bool,
    updateCustom: PropTypes.func,
    direction: PropTypes.string,
    border: PropTypes.bool,

    infiniteWidth: PropTypes.string,
    infiniteHeight: PropTypes.string,

    updateFilter: PropTypes.func.isRequired,
    checkFilter: PropTypes.func.isRequired,
    searchFilter: PropTypes.func.isRequired,
    showAll: PropTypes.func,
    resetSearch: PropTypes.func.isRequired,
    uncheckAll: PropTypes.func.isRequired,
    search: PropTypes.bool,
    clearall: PropTypes.bool,
    infinite: PropTypes.bool,
    multipleSelect: PropTypes.bool,
    expandable: PropTypes.bool
  };

  static defaultProps = {
    name: '',
    testId: 'MozartInputBox',
    search: false,
    clearall: true,
    direction: 'vertical',
    border: true,
    excludeSelect: [],
    infinite: false,
    multipleSelect: true,
    expandable: false
  }

  constructor(props) {
    super(props);
    this.state = {
      breadcrums: [],
      search_value: ''
    };

    this.list = [];
    this.scrollTop = 0;
  }

  componentWillReceiveProps(nextProps) {
    if (typeof nextProps.filter.search_result === 'undefined') {
      this.setState({ search_value: '' });
    }
  }

  getCheckBoxesListExpandable() {
    let RETURN_DATA = [];

    const getCheckBoxList = filter => {
      const DATA = [];
      const DATASTAYFIRST = [];
      // get all children at current level
      const keys = this.getOrderCheckBoxesByNameKey(filter);
      if (this.state.search_value.trim().length < 3) {
        keys.forEach((key) => {
          if (!filter.children[key].stayfirst) {
            DATA.push(filter.children[key]);
          } else {
            DATASTAYFIRST.push(filter.children[key]);
          }
        });
      } else {
        // search case
        if (filter.search_result && filter.search_result.length > 0) {
          filter.search_result.forEach((item) => {
            item.expanded = false;
            item.left = 0;
            if (!item.stayfirst) {
              DATA.push(item);
            } else {
              DATASTAYFIRST.push(item);
            }
          });
        }
      }

      // new array of tree
      const currData = DATASTAYFIRST.concat(DATA);

      // find the index to reorder
      let currIndex = 0;
      RETURN_DATA.forEach((item, index) => {
        if (String(item.id) === String(filter.id)) {
          currIndex = index;
        }
      });
      // inject current expanded selection into the correct position of tree
      const firstDATA = RETURN_DATA.slice(0, currIndex + 1);
      const lastDATA = RETURN_DATA.slice(currIndex, RETURN_DATA.length);
      RETURN_DATA = firstDATA.concat(currData.concat(lastDATA));

      if (this.state.search_value.trim().length < 3) {
        keys.forEach((key) => {
          if (filter.children[key].expanded) {
            getCheckBoxList(filter.children[key], filter.children[key].name);
            Object.keys(filter.children[key].children).forEach(itemKey => {
              if (filter.children[key].children[itemKey].expanded) {
                getCheckBoxList(filter.children[key].children[itemKey], filter.children[key].children[itemKey].name);
              }
            });
          }
        });
      }
    };

    let rootFilter = this.props.filter;
    while (rootFilter.parent && rootFilter.filter !== null) {
      rootFilter = rootFilter.parent;
    }

    getCheckBoxList(rootFilter);
    RETURN_DATA = removeDuplicates(RETURN_DATA, 'id');
    return RETURN_DATA.map(item => this.getCheckBox(item, item.name));
  }

  getCheckBoxesList() {
    const {filter, name} = this.props;
    const DATA = [];
    const DATASTAYFIRST = [];
    // get all children at current level
    const keys = this.getOrderCheckBoxesByNameKey(filter);
    if (this.state.search_value.trim().length < 3) {
      keys.forEach((key) => {
        if (!filter.children[key].stayfirst) {
          DATA.push(this.getCheckBox(filter.children[key], name));
        } else {
          DATASTAYFIRST.push(this.getCheckBox(filter.children[key], name));
        }
      });
    } else {
      // search case
      if (filter.search_result && filter.search_result.length > 0) {
        filter.search_result.forEach((item) => {
          if (!item.stayfirst) {
            DATA.push(this.getCheckBox(item, name));
          } else {
            DATASTAYFIRST.push(this.getCheckBox(item, name));
          }
        });
      }
    }
    return DATASTAYFIRST.concat(DATA);
  }

  getCheckBoxes() {
    const {infinite, infiniteWidth, infiniteHeight, expandable} = this.props;
    this.list = !expandable ? this.getCheckBoxesList() : this.getCheckBoxesListExpandable();
    if (this.scrollTop > this.list.length * 30) {
      this.scrollTop = 0;
    }
    this.listElem = (<List
      ref="list"
      width={infiniteWidth ? infiniteWidth : 410}
      height={infiniteHeight ? infiniteHeight : 300}
      rowCount={this.list.length}
      rowHeight={30}
      onScroll={(data) => {
        this.scrollTop = data.scrollTop;
      }}
      style={{maxWidth: '1500px'}}
      scrollTop={this.scrollTop}
      rowRenderer={({
        key,
        index,
        style
      }) => {
        return (
          <div key={key} style={style}>
            {this.list[index]}
          </div>);
      }}
    />);

    return infinite ? this.listElem : this.list;
  }

  getInnerLevelIcon(id, checkboxNode) {
    const {expandable} = this.props;
    const style = {margin: '0px 5px', fontSize: '0.9em', fontWeight: '400', cursor: 'pointer'};
    if (!expandable && checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0) {
      return <MozartCheckboxLabelLevelDown
        data-hint="Go to next level"
        id={id + '_inner'}
        className='hint--top'
        style={style}
        onClick={this.handleInnerLevelClick.bind(this, checkboxNode)}
      >
        <span className="icon-Down"></span>
      </MozartCheckboxLabelLevelDown>;
    }
    if (expandable && !checkboxNode.expanded && checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0) {
      return <MozartCheckboxLabelLevelDown
        data-hint="Go to next level"
        id={id + '_inner'}
        className='hint--top'
        style={style}
        onClick={this.handleInnerLevelClick.bind(this, checkboxNode)}
      >
        <span className="icon-PlusCircle"></span>
      </MozartCheckboxLabelLevelDown>;
    }
    if (expandable && checkboxNode.expanded && checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0) {
      return <MozartCheckboxLabelLevelDown
        data-hint="Go to next level"
        id={id + '_inner'}
        className='hint--top'
        style={style}
        onClick={this.handleInnerLevelClick.bind(this, checkboxNode)}
      >
        <span className="icon-MinusCircle"></span>
      </MozartCheckboxLabelLevelDown>;
    }

    return <span style={{width: '37px', display: 'inline-block'}} />
  }

  getCheckBox(checkboxNode, filterName) {
    const {multipleSelect, expandable, direction, excludeSelect, toolTipPlacement, testId} = this.props;
    const id = checkboxNode.id + '_' + filterName.toLowerCase().split(' ').join('_');
    const name = filterName;
    const hoverText = this.getHoverText(checkboxNode);
    const defaultChecked = typeof checkboxNode.checked !== 'undefined' ? checkboxNode.checked : false;
    const style = direction === 'horizontal' ? {whiteSpace: 'nowrap', display: 'inline', height: '30px'} : {whiteSpace: 'nowrap', display: 'block', height: '30px'};

    const expand = this.getInnerLevelIcon(id, checkboxNode);
    const input = (<input
      defaultChecked={defaultChecked}
      key={filterName + '-' + checkboxNode.id}
      type={multipleSelect ? 'checkbox' : 'radio'}
      id={id}
      data-qa={testId + id}
      name={multipleSelect ? name + '_' + id : id}
      onChange={this.handleCheckBoxClick.bind(this, checkboxNode)}
    />);

    const label = (<label htmlFor={id} title={hoverText.split('>').length > 1 ? hoverText : 'Hierarchy'}>
      {toolTipPlacement !== 'none' ?
      <ToolTip
        key="binary_checkbox_tooltip"
        node={<span>{checkboxNode.name}</span>}
        data={hoverText.split('>').length > 1 && <p><strong>{hoverText}</strong></p>}
        placement={toolTipPlacement ? toolTipPlacement : 'left'}
      /> : <span>{checkboxNode.name}</span>}
      {!expandable ? this.getInnerLevelIcon(id, checkboxNode) : ''}
    </label>);
    if (excludeSelect.indexOf(checkboxNode.id) !== -1) { return ''; }
    if (!expandable) {
      return multipleSelect ?
      <CheckBox key={checkboxNode.id} style={style}>{input}{label}</CheckBox> :
      <Radio key={checkboxNode.id} style={style}>{input}{label}</Radio>;
    } else {
      style.left = checkboxNode.left;
      return multipleSelect ?
      <CheckBox key={checkboxNode.id + '_' + checkboxNode.parent.id + '_' + checkboxNode.name} style={style}>{expand}{input}{label}</CheckBox> :
      <Radio key={checkboxNode.id + '_' + checkboxNode.parent.id + '_' + checkboxNode.name} style={style}>{expand}{input}{label}</Radio>;
    }
  }

  getCustomInput() {
    const {customName, customValue, filterName, testId} = this.props;
    const id = filterName ? testId + '_' + filterName.toLowerCase().split(' ').join('_') : testId;

      const input = (<input
      defaultChecked={customValue}
      ref="custom"
      key={filterName + '_custom_' + customValue}
      type="checkbox"
      id='custom'
      data-qa={'custom_' + id + '_' + testId}
      name="custom"
      onChange={() => {
        this.props.updateCustom();
      }}
    />);
    const label = (<label htmlFor="custom" title={customName} >{customName}</label>);
    return <MozartCheckboxCustom key={customValue}><CheckBox>{input}{label}</CheckBox></MozartCheckboxCustom>;
  }

  getOrderCheckBoxesByNameKey(filter) {
    const keysinorder = [];
    const keysObj = [];
    if (filter && filter.children && filter.children !== null) {
      Object.keys(filter.children).forEach((key) => { keysObj.push(filter.children[key]); });
    }
    keysObj.sort((item1, item2) => {
      let item1_ = '';
      let item2_ = '';
      if (item1.index && item2.index) {
        item1_ = item1.index;
        item2_ = item2.index;
      } else {
        item1_ = item1.name;
        item2_ = item2.name;
      }
      if (item1_ > item2_) {
        return 1;
      }
      if (item1_ < item2_) {
        return -1;
      }
      return 0;
    });
    keysObj.forEach( (item) => {
      keysinorder.push(item.id);
    });
    return keysinorder;
  }

  getCheckBoxBreadCrums() {
    const {filter} = this.props;
    const hierarchy = [filter];
    let checkbox = filter;

    while (checkbox && checkbox.parentId !== null && checkbox.parent) {
      hierarchy.push(checkbox.parent);
      checkbox = checkbox.parent;
    }
    return (hierarchy.length > 1 ?
    <BreadCrum
      style={{fontSize: '12px'}}
      data={hierarchy.reverse()}
      onClick={this.handleBreadCrumClick.bind(this)} /> : '');
  }

  getHoverText(filter) {
    let filterData = Object.assign({}, filter);
    const hierarchy = [];
    const hover = [];
    while (filterData.parent) {
      hierarchy.push(filterData.parent);
      filterData = filterData.parent;
    }
    hierarchy.forEach((item) => {
      hover.push(item.name);
    });
    return hover.reverse().join(' > ');
  }

  getSearchInput() {
    const {filter, testId} = this.props;
    return (<MozartFilterSearch>
      <input
        onChange={debounce(() => {
          this.search();
          if (this.refs.list) { this.refs.list.forceUpdateGrid(); }
        }, 800).bind(this)}
        type="text"
        placeholder="Search"
        ref="search"
        id={'binary_checkbox_search_' + filter.name}
        data-qa={'binary_checkbox_search_' + filter.name + '_' + testId}
        maxLength={80}
        defaultValue={this.state.search_value}
        addonBefore={<span className="icon-Search" />}
      />
      <span className="icon-Search"></span>
    </MozartFilterSearch>);
  }

  search() {
    const value = this.refs.search.value;
    this.setState({ search_value: value.trim() }, () => {
      this.scrollTop = 0;
      if (value.trim().length === 0) {
        this.props.resetSearch();
      }
      if (value.length > 2) {
        this.props.searchFilter(this.state.search_value);
      }
    });
  }

  handleBreadCrumClick(filter) {
    this.props.updateFilter(filter);
  }

  handleInnerLevelClick(filterClicked) {
    const {expandable} = this.props;
    if (this.refs.search) {
      this.refs.search.value = '';
    }
    this.setState({
      search_value: ''
    }, () => {
      if (expandable) {
        let rootFilter = filterClicked;
        filterClicked.expanded = !filterClicked.expanded;
        if (filterClicked.expanded) {
          const currTree = [];
          while (rootFilter.parent && rootFilter.filter !== null) {
            rootFilter = rootFilter.parent;
            rootFilter.expanded = true;
            currTree.push(rootFilter);
          }

          let currLeft = 40;
          currTree.reverse().forEach(item => {
            Object.keys(item.children).forEach(key => {
              if (key !== item.id && item.parent && item.parent !== null) {
                item.children[key].left = currLeft;
              }
            });
            if (item.id && item.id !== 0 && item.parentId !== null) {
              currLeft = currLeft + 40;
            }
          });
          Object.keys(filterClicked.children).forEach(key => {
            filterClicked.children[key].left = currLeft;
          });
        }
        this.props.updateFilter(filterClicked);
      } else {
        this.props.updateFilter(filterClicked);
      }
    });
  }

  uncheckAll() {
    if (this.refs.search) { this.refs.search.value = ''; }
    this.setState({
      search_value: ''
    }, () => {
      this.props.uncheckAll();
      this.search();
      if (this.refs.list) { this.refs.list.forceUpdateGrid(); }
    });
  }

  handleCheckBoxClick(filter, event) {
    const {name, infinite, checkFilter} = this.props;
    if (checkFilter) {
      checkFilter(name, filter, event.target.checked, () => {
        if (infinite) {
          this.list = this.getCheckBoxesList();
          this.refs.list.forceUpdateGrid();
        }
      });
    }
  }

  render() {
    const {filter, expandable, updateCustom, name, search, clearall} = this.props;
    const CHECKBOX_RENDER = this.getCheckBoxes();
    const BREADCRUMS_RENDER = !expandable ? this.getCheckBoxBreadCrums() : [];

    return (
      <div data-qa={this.props.testId}>
        {filter && search &&
          this.getSearchInput()}
        {filter && updateCustom &&
          this.getCustomInput()}
        {(filter && !expandable) &&
        <BREADCRUMS>
          {BREADCRUMS_RENDER}
        </BREADCRUMS>}
        {filter &&
        <MozartfilterCheckboxContainer key={name.split(' ').join('')} style={{overflow: 'inherit', maxHeight: 'none'}} >
          {CHECKBOX_RENDER.length === 0 ? 'No Results Found !' : <div key={Math.random()}>{CHECKBOX_RENDER}</div>}
          {CHECKBOX_RENDER.length < 52 && this.props.showAll &&
            <p className={this.styles.show_all} onClick={this.props.showAll.bind(this)}>Show More</p> }
        </MozartfilterCheckboxContainer>}
        {filter && clearall &&
        <ClearAll
          id={'binary_filter_clearall_' + name.split(' ').join('_').toLowerCase()}
          onClick={this.uncheckAll.bind(this)}>
          clear all
        </ClearAll>}
        {typeof filter === 'undefined' &&
          <p>No Data</p>}
      </div>
    );
  }
}
