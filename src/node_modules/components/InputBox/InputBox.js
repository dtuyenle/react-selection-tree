import React, {Component} from 'react';
import PropTypes from 'prop-types';
import CheckBox from './../CheckBox';
import Radio from './../Radio';
import BreadCrum from './../BreadCrum';
import ToolTip from './../ToolTip';
import {List} from 'react-virtualized';
import styled from 'styled-components';

const removeDuplicates = (myArr, prop) => {
  return myArr.filter((obj, pos, arr) => {
    return arr.map(mapObj => mapObj[prop]).indexOf(obj[prop]) === pos;
  });
};

const searchIcon = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARhSURBVGhD1ZpbyGZTGMc/jHNyisjZjNOFQyPcTCZFIYQL05waJHeomZrBpChuRk2GQo6RUrhwmCYulZwPGcwNzTCOQ85R5PT7YdXTau3x7r3X/mb716/eb7/f+6y19l7rOb3vVA8dCBfCtXAHPAD3wRpYBufC3jBKHQw3wDvw5wT8Dq/A1bAvbHO5gPvhFyhNeBJ+hFthL5h2bQdXgZMoTU5+hU3wOrwJm+E3KP2vfAGXwLRpD3gGSpN5F26BU2FHyLUznAG3wUYo2bgbSp+tqv3AO5wP7h0/E9rIpzoP3ofc3jrYDQbRnvAaxAF/hkvBSXXVTqCHy7fdU7ADVJUTfRriQJ/AyVBLZ8N3EMe4HarqGogDfAyHQG2dAHExf8D5UEW62OidfoJTYChdAHGbfQS7Q28ZJ5JRuQyG1s0Qx7wOesmnEYPdG9DnYE8qPdankMb9CnaFzloJyZi0dbF9dAXEsedDZxngkqH3vDCNMihugTS+7riTDoBkRIzYUdvDif+8HEx3QRr/e5gBrWUqHhdyGkSZF5lvDamLIc7hJGgto20yYAKY3w3zrfwp1dbhEBdiStNaFkXJwAdeCHJb+agf/fuv4eQ4MaYshdZ6EJKBt7wQpFv2+tfQad+20LeQ5nGjF9oqBsK3vRB0PKT3TMuHVExZOgVGa+xk4EMvBEWP9qQXBpJP23wrjXU5tJb7MRlwn+4CSabXMeLPgSF0NKQx5DxoLbsd0Ui+hZ6D9N56GKIQWghxDrOgtWzZ2O1IRixPo66EOMgTUDsPewiSfWv+znoVkiEbCXGi1t+enfS+3Au16m2fsC4+2bY/1ln2neJE8y7HRRAPozwP+0NfrYBo1wqys2yexaLKwJjf8ZsgDijeSTPnrgXRPhDjhwlr7227CuIkvVO5lkM8TwkDpvvcnOkgmHTb3QPRTie3m8sOYEyndcXnQK7TwTZonECO29C7uxia7nDuRGw/VcsePBvRuNG2lIk6ubmwGl4EPc2XsAEegSWwtUrvLIjxyddmEVVlBzAu5gfoFKAa5JMwy45j2KirLhtpayEO5LnwsPepp3Uo+U2K2IjQvlu32tPRt5f6vp+BNXabGKItnUT0Tk3Y0Uyv3bKHQW958Ewo8/ghOoU7wfhyBFhPJPm5o8C042HIu4rihJ/NrpWw13UkVJHnQ4OlgRJuvW/+pfR+5AUwSdRh2Cot/U+k6mIMeNeDnqk02CRYtC2C+PTyPK8JveJMqCYP4wKwNtGblQaNmLeZlzX1yYxTpc+VsA/tlq0uz4JtIhsFfvlpeWplZ6vV7TjJHZwNpUk34TcDbstR6iUoTboJW6zHwOh0KPyXM8kxDBwLo5NeyQNdmnQTn8NxMDp5pjzQpUk34WJsWY1O1uptF/M4jFK6WL1TadIlDMKjlS42fgG0NVz0qKWL1TuVJh+xsh29dLEe6NIC5GXo9VXddEoX6+9XSovwxw3/K9nQeAysaTwT/spoiI7nttbU1F8ecld/HmfjEQAAAABJRU5ErkJggg==';

const Chevron = styled.i`
  position: absolute;
  margin: 6px;

  :before, :after{
    position: absolute;
    display: block;
    content: "";
    border: 6px solid transparent;
  }

  :before{
    top: 0;
    border-top-color: ${props => props.color};
  }

  :after{
    top: -3px;
    border-top-color: #fff;
  }
`;

const CheckboxContainer = styled.div`
  padding: 12px;
  display: flex;
  max-height: 280px;
  margin-top: 10px;
  border: 1px solid #CCC;
  overflow: auto;
  overflow-x: hidden;

  span {
    margin: 0;
    font-weight: 400;
  }
`;

const CheckboxCustom = styled.div`
  font-size: 0.8em;
  margin: 1em 0;

  label:before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 8px;
    height: 8px;
    border: 1px solid #ddd;
    background: #fff;
  }
`;

const CheckboxLabel = styled.label`
  font-size: 1em;
`;

const Search = styled.div`
  display: flex;
  &:after {
    content: "";
    display: table;
    clear: both;
  }

  img {
    float: left;
    background: #EEE;
    color: #666;
    border: 1px #CCC solid;
    border-right: none;
    padding: 0.68em;
    width: 15px;
    height: 15px;
  }

  input {
    padding: 0.5em;
    border-radius: 0px;
    border: 1px #CCC solid;
    flex-grow: 1;
  }
`;

const ClearAll = styled.div`
  margin-top: 10px;
  cursor: pointer;
  text-align: left;
  font-size: 0.9em;
`;

const ShowAll = styled.div`
  color: #6090C3;
  margin: 10px 8px 0 8px;
`;

export default class InputBox extends Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    color: PropTypes.string,
    selectcolor: PropTypes.string,
    filter: PropTypes.object.isRequired,
    excludeSelect: PropTypes.array,
    toolTipPlacement: PropTypes.string,

    customName: PropTypes.string,
    customValue: PropTypes.bool,
    updateCustom: PropTypes.func,
    direction: PropTypes.string,

    updateFilter: PropTypes.func.isRequired,
    checkFilter: PropTypes.func.isRequired,
    searchFilter: PropTypes.func.isRequired,
    showAll: PropTypes.func,
    resetSearch: PropTypes.func.isRequired,
    uncheckAll: PropTypes.func.isRequired,
    search: PropTypes.bool,
    clearall: PropTypes.bool,
    infinite: PropTypes.bool,
    multipleSelect: PropTypes.bool,
    expandable: PropTypes.bool,

    infiniteWidth: PropTypes.string,
    infiniteHeight: PropTypes.string,
  };

  static defaultProps = {
    name: '',
    search: false,
    clearall: true,
    direction: 'vertical',
    timer: null,
    excludeSelect: [],
    infinite: false,
    multipleSelect: true
  }

  constructor(props) {
    super(props);
    this.state = {
      breadcrums: [],
      search_value: '',
    };

    this.list = [];
  }

  componentWillReceiveProps(nextProps) {
    if (typeof nextProps.filter.search_result === 'undefined') {
      this.setState({ search_value: '' });
    }
  }

  getCheckBoxesList() {
    const {filter, name} = this.props;
    const DATA = [];
    const DATASTAYFIRST = [];
    const keys = this.getOrderCheckBoxesByNameKey(filter);
    if (this.state.search_value.trim().length < 3) {
      keys.forEach(key => {
        console.log(filter, key);
        if (!filter.children[key].stayfirst) {
          DATA.push(this.getCheckBox(filter.children[key], name));
        } else {
          DATASTAYFIRST.push(this.getCheckBox(filter.children[key], name));
        }
      });
    } else {
      if (filter.search_result && filter.search_result.length > 0) {
        filter.search_result.forEach(item => {
          if (!item.stayfirst) {
            DATA.push(this.getCheckBox(item, name));
          } else {
            DATASTAYFIRST.push(this.getCheckBox(item, name));
          }
        });
      }
    }
    return DATASTAYFIRST.concat(DATA);
  }

  getCheckBoxesListExpandable() {
    let RETURN_DATA = [];

    const getCheckBoxList = filter => {
      const DATA = [];
      const DATASTAYFIRST = [];
      // get all children at current level
      const keys = this.getOrderCheckBoxesByNameKey(filter);
      if (this.state.search_value.trim().length < 3) {
        keys.forEach((key) => {
          console.log(filter, key);
          if (!filter.children[key].stayfirst) {
            DATA.push(filter.children[key]);
          } else {
            DATASTAYFIRST.push(filter.children[key]);
          }
        });
      } else {
        // search case
        if (filter.search_result && filter.search_result.length > 0) {
          filter.search_result.forEach((item) => {
            if (!item.stayfirst) {
              DATA.push(item);
            } else {
              DATASTAYFIRST.push(item);
            }
          });
        }
      }

      // new array of tree
      const currData = DATASTAYFIRST.concat(DATA);

      // find the index to reorder
      let currIndex = 0;
      RETURN_DATA.forEach((item, index) => {
        if (String(item.id) === String(filter.id)) {
          currIndex = index;
        }
      });
      // inject current expanded selection into the correct position of tree
      const firstDATA = RETURN_DATA.slice(0, currIndex);
      const lastDATA = RETURN_DATA.slice(currIndex, RETURN_DATA.length);
      RETURN_DATA = firstDATA.concat(currData.concat(lastDATA));

      if (this.state.search_value.trim().length < 3) {
        keys.forEach((key) => {
          if (filter.children[key].expanded) {
            getCheckBoxList(filter.children[key], filter.children[key].name);
            Object.keys(filter.children[key].children).forEach(itemKey => {
              if (filter.children[key].children[itemKey].expanded) {
                getCheckBoxList(filter.children[key].children[itemKey], filter.children[key].children[itemKey].name);
              }
            });
          }
        });
      }
    };

    let rootFilter = this.props.filter;
    while (rootFilter.parent && rootFilter.filter !== null) {
      rootFilter = rootFilter.parent;
    }
    getCheckBoxList(rootFilter);

    RETURN_DATA = removeDuplicates(RETURN_DATA, 'id');
    console.log(RETURN_DATA);
    return RETURN_DATA.reverse().map(item => this.getCheckBox(item, item.name));
  }

  getCheckBoxes() {
    const {infinite, infiniteWidth, infiniteHeight, expandable} = this.props;
    this.list = !expandable ? this.getCheckBoxesList() : this.getCheckBoxesListExpandable();
    this.listElem = (<List
      ref="list"
      width={infiniteWidth ? infiniteWidth : 410}
      height={infiniteHeight ? infiniteHeight : 300}
      rowCount={this.list.length}
      rowHeight={30}
      rowRenderer={({
        key,
        index,
        style
      }) => {
        return (
          <div key={key} style={style}>
            {this.list[index]}
          </div>);
      }}
    />);

    return infinite ? this.listElem : this.list;
  }

  getCheckBox(checkboxNode, filterName) {
    const {expandable, multipleSelect, direction, excludeSelect, toolTipPlacement} = this.props;
    const id = checkboxNode.id + '_' + filterName.toLowerCase().split(' ').join('_');
    const name = filterName;
    const hoverText = this.getHoverText(checkboxNode);
    const defaultChecked = typeof checkboxNode.checked !== 'undefined' ? checkboxNode.checked : false;
    const style = direction === 'horizontal' ? {display: 'inline'} : {display: 'block'};

    const input = (<input
      defaultChecked={defaultChecked}
      // ref={checkboxNode.id}
      key={checkboxNode.id}
      type={multipleSelect ? 'checkbox' : 'radio'}
      id={id}
      name={multipleSelect ? name + '_' + id : id}
      onChange={this.handleCheckBoxClick.bind(this, checkboxNode)}
    />);

    const label = (<CheckboxLabel htmlFor={id} title={hoverText}>
      <ToolTip
        key="binary_checkbox_tooltip"
        node={<span>{checkboxNode.name}</span>}
        data={hoverText.split('>').length > 1 && <p><strong>{hoverText}</strong></p>}
        placement={toolTipPlacement ? toolTipPlacement : 'bottom'}
      />
      {checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0 &&
      <span
        data-hint="Go to next level"
        id={id + '_inner'}
        className="hint--top"
        onClick={this.handleInnerLevelClick.bind(this, checkboxNode)}
      >
        {this.getInnerLevelIcon(id, checkboxNode)}
      </span> }
    </CheckboxLabel>);
    if (excludeSelect.indexOf(checkboxNode.id) !== -1) { return <span />; }
    if (!expandable) {
      return multipleSelect ?
      <CheckBox key={checkboxNode.id} style={style}>{input}{label}</CheckBox> :
      <Radio key={checkboxNode.id} style={style}>{input}{label}</Radio>;
    } else {
      style.left = checkboxNode.left;
      return multipleSelect ?
      <CheckBox key={checkboxNode.id + '_' + checkboxNode.parent.id + '_' + checkboxNode.name} style={style}>{input}{label}</CheckBox> :
      <Radio key={checkboxNode.id + '_' + checkboxNode.parent.id + '_' + checkboxNode.name} style={style}>{input}{label}</Radio>;
    }
  }

  getCustomInput() {
    const {customName, customValue} = this.props;
    const input = (<input
      defaultChecked={customValue}
      ref="custom"
      key={'custom_' + customValue}
      type="checkbox"
      id="custom"
      name="custom"
      onChange={() => {
        this.props.updateCustom();
      }}
    />);
    const label = (<CheckboxLabel htmlFor="custom" title={customName}>{customName}</CheckboxLabel>);
    return <div key={customValue}><CheckboxCustom><CheckBox>{input}{label}</CheckBox></CheckboxCustom></div>;
  }

  getOrderCheckBoxesByNameKey(filter) {
    const keysinorder = [];
    const keysObj = [];
    if (filter && filter.children && filter.children !== null) {
      Object.keys(filter.children).forEach((key) => { keysObj.push(filter.children[key]); });
    }
    keysObj.sort((item1, item2) => {
      let item1_ = '';
      let item2_ = '';
      if (item1.index && item2.index) {
        item1_ = item1.index;
        item2_ = item2.index;
      } else {
        item1_ = item1.name;
        item2_ = item2.name;
      }
      if (item1_ > item2_) {
        return 1;
      }
      if (item1_ < item2_) {
        return -1;
      }
      return 0;
    });
    keysObj.forEach( (item) => {
      keysinorder.push(item.id);
    });
    return keysinorder;
  }

  getCheckBoxBreadCrums() {
    const {color, filter} = this.props;
    const hierarchy = [filter];
    let checkbox = filter;

    while (checkbox && checkbox.parentId !== null && checkbox.parent) {
      hierarchy.push(checkbox.parent);
      checkbox = checkbox.parent;
    }
    return (hierarchy.length > 1 ? <BreadCrum
      style={{fontSize: '12px', color: color}}
      data={hierarchy.reverse()}
      onClick={this.handleBreadCrumClick.bind(this)} /> : '');
  }

  getHoverText(filter) {
    let filterData = Object.assign({}, filter);
    const hierarchy = [];
    const hover = [];
    while (filterData.parent) {
      hierarchy.push(filterData.parent);
      filterData = filterData.parent;
    }
    hierarchy.forEach((item) => {
      hover.push(item.name);
    });
    return hover.reverse().join(' > ');
  }

  getSearchInput() {
    const {filter} = this.props;
    return (
      <Search>
        <img alt="search" src={searchIcon} />
        <input
          onChange={this.search.bind(this)}
          type="text"
          placeholder="Search"
          ref="search"
          id={'checkbox_search_' + filter.name.split(' ').join('')}
          maxLength={80}
          value={this.state.search_value}
        />
      </Search>);
  }

  getInnerLevelIcon(id, checkboxNode) {
    const {expandable, color, selectcolor} = this.props;
    console.log(this.props);
    const style = {fontSize: '20px', margin: '0 10px', fontWeight: '900'};
    if (!expandable && checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0) {
      return <Chevron color={color} />;
    }
    if (expandable && !checkboxNode.expanded && checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0) {
      return <span style={Object.assign({color: color}, style)}>+</span>;
    }
    if (expandable && checkboxNode.expanded && checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0) {
      return <span style={Object.assign({color: selectcolor}, style)}>-</span>;
    }
  }

  search(event) {
    if (event.target.value.trim().length === 0) {
      this.props.resetSearch();
    }
    if (event.target.value.length < 3) {
      this.setState({ search_value: event.target.value });
    } else {
      this.setState({ search_value: event.target.value }, () => {
        this.props.searchFilter(this.state.search_value);
      });
    }
  }

  handleBreadCrumClick(filters) {
    this.props.updateFilter(filters);
  }

  handleInnerLevelClick(filterClicked) {
    const {filter, expandable} = this.props;
    this.setState({
      search_value: ''
    }, () => {
      filterClicked.expanded = !filterClicked.expanded;
      if (filterClicked.expanded) {
        Object.keys(filterClicked.children).forEach(key => {
          filterClicked.children[key].left = filterClicked.left + 40;
        });
      }

      if (expandable) {
        this.props.updateFilter(filter);
      } else {
        this.props.updateFilter(filterClicked);
      }
    });
  }

  uncheckAll() {
    this.setState({
      search_value: ''
    }, () => {
      this.props.uncheckAll();
      if (this.refs.list) { this.refs.list.forceUpdateGrid(); }
    });
  }

  handleCheckBoxClick(filter, event) {
    const {name, checkFilter} = this.props;
    this.list = this.getCheckBoxesList();
    if (checkFilter) {
      checkFilter(name, filter, event.target.checked);
    }
  }

  render() {
    const {expandable, filter, color, updateCustom, name, search, clearall, infinite} = this.props;
    const CHECKBOX_RENDER = this.getCheckBoxes();
    const BREADCRUMS_RENDER = !expandable ? this.getCheckBoxBreadCrums() : '';

    return (
      <div>
        {filter && search &&
          this.getSearchInput()}
        {filter && updateCustom &&
          this.getCustomInput()}
        {filter &&
        <div>
          {BREADCRUMS_RENDER}
        </div>}
        {filter &&
        <CheckboxContainer key={name.split(' ').join('')} style={infinite ? {overflow: 'inherit', maxHeight: 'none'} : {}}>
          {CHECKBOX_RENDER.length === 0 ? <p>No Results Found !</p> : <div key={Math.random()}>{CHECKBOX_RENDER}</div>}
          {CHECKBOX_RENDER.length < 52 && this.props.showAll &&
            <ShowAll onClick={this.props.showAll.bind(this)}>Show More</ShowAll> }
        </CheckboxContainer>}
        {filter && clearall &&
        <ClearAll
          style={{color: color}}
          id={'binary_filter_clearall_' + name.split(' ').join('_').toLowerCase()}
          onClick={this.uncheckAll.bind(this)}>
          clear all
        </ClearAll>}
        {typeof filter === 'undefined' &&
          <p>No Data</p>}
      </div>
    );
  }
}
