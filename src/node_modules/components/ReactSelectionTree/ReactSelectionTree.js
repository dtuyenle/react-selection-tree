import React, {Component} from 'react';
import PropTypes from 'prop-types';
import InputBox from '../InputBox';
import {flattenParent, flattenChildren, flattenNode, copyTreeState} from '../utils';
import {clone} from 'ramda';
import styled from 'styled-components';
import color from '../color';

const Container = styled.div`
  width: 100%;
`;

const Selected = styled.h5`
  margin-bottom: 2em;
`;

const SelectedItem = styled.span`
  border: 1px solid ${color.purple_main};
  border-radius: 5px;
  padding: 5px 10px;
`;

export default class ReactSelectionTree extends Component {

  static propTypes = {
    /** qa attribute */
    testId: PropTypes.string,
    /** name of the selection tree must be unique */
    name: PropTypes.string.isRequired,
    /** data tree */
    data: PropTypes.object.isRequired,
    defaultData: PropTypes.array,
    /** array of node id that don't want to include */
    excludeSelect: PropTypes.array,
    /** tooltip placement when mouse over */
    toolTipPlacement: PropTypes.string,
    /** callback when selection data is updated */
    collectFilterData: PropTypes.func.isRequired,
    /** show selected data */
    showSelected: PropTypes.bool,
    /** not working yet */
    color: PropTypes.string,
    /** not working yet */
    selectcolor: PropTypes.string,
    /** breadcrum callback when clicked */
    breadcrumClick: PropTypes.func.isRequired,
    /** node on click callback */
    check: PropTypes.func.isRequired,
    /** on search callback */
    search: PropTypes.func.isRequired,
    /** reset callback */
    reset: PropTypes.func.isRequired,
    /** uncheck all callback */
    uncheckAll: PropTypes.func.isRequired,
    /** show search toggle */
    showSearch: PropTypes.bool,
    /** show clear all toggle */
    showClearAll: PropTypes.bool,
    /** if true react-virtualized kick in (only use if you have more than say 500 to 1000 nodes) */
    infinite: PropTypes.bool,
    /** virtualize width container */
    infiniteWidth: PropTypes.string,
    /** virtualize height container */
    infiniteHeight: PropTypes.string,
    /** if true check box if false radio box */
    multipleSelect: PropTypes.bool,
    /** if true you can expand as a tree instead of going into nested level */
    expandable: PropTypes.bool,
    /** if true checkbox radiobox not clickable */
    disabled: PropTypes.bool
  };

  static defaultProps = {
    testId: 'MozartSelectionTree',
    disabled: false,
    infinite: false,
    name: '',
    color: '#6090C3',
    defaultData: [],
    selectcolor: '#FF8800',
    showSearch: true,
    showSelected: false,
    showClearAll: true,
    multipleSelect: false,
    expandable: false,
    toolTipPlacement: 'left'
  };

  constructor(props) {
    super(props);
    this.state = {
      data: false,
      originalData: false,
      flatData: false,
      selectedData: []
    }
  }

  componentDidMount() {
    this.load();
  }

  load() {
    const data = clone(this.props.data);
    const defaultData = this.props.defaultData;
    const flatData = flattenNode(data, false);
    const selectedData = [];
    let currNode = data;
    Object.keys(flatData).forEach(key => {
      const item = flatData[key];
      if (defaultData.map(item => String(item)).indexOf(String(item.id)) !== -1) {
        item.checked = true;
        selectedData.push(item);
        flattenChildren(item, true);
        currNode = item.parent ? item.parent : item;
      }
    });
    this.setState({
      data: currNode,
      flatData: flatData,
      selectedData: selectedData,
      originalData: clone(data)
    });
  }

  reset() {
    const flatData = this.state.flatData;
    Object.keys(flatData).forEach(key => {
      if (flatData[key] && typeof flatData[key].checked !== 'undefined') {
        flatData[key].checked = false;
      }
    });
    let rootData = this.state.data;
    while (rootData.parent && rootData.parent !== null) { rootData = rootData.parent; }
    rootData.search_result = undefined;
    this.setState({
      data: Object.assign({}, rootData),
      flatData: Object.assign({}, this.state.flatData)
    }, () => {
      this.collectData();
    });
  }

  checkIfSelected(item) {
    let check = (item && item.parent && item.parent !== null && !item.parent.checked && item.checked);
    check = check ? true : (typeof item.parent === 'undefined' && item.checked);
    check = check ? true : (item.parent && item.parent === null && item.checked);
    return check;
  }

  collectData() {
    if (this.props.collectFilterData) {
      const selectedData = [];
      Object.keys(this.state.flatData).forEach(key => {
        if (this.checkIfSelected(this.state.flatData[key])) {
          selectedData.push(this.state.flatData[key]);
        }
      });
      this.setState({
        selectedData: selectedData
      }, () => {
        this.props.collectFilterData(selectedData, this.state.data, this.state.originalData);
      });
    }
  }

  update(data, callback) {
    this.setState({
      data: Object.assign({}, data),
      flatData: Object.assign({}, this.state.flatData)
    }, () => {
      if (callback) { callback(data, this.state.flatData); }
      this.collectData();
    })
  }

  updateOriginalFromData() {
    copyTreeState(this.state.originalData, this.state.data);
    this.setState({
      originalData: Object.assign({}, this.state.originalData)
    }, () => {
      this.collectData();
    });
  }

  updateDataFromOriginal() {
    copyTreeState(this.state.data, this.state.originalData);
    const rootNode = Object.assign({}, this.state.data);
    this.setState({
      data: rootNode,
      flatData: flattenNode(rootNode)
    }, () => {
      this.collectData();
    });
  }

  checkEmpty() {
    return this.state.data && this.state.data !== null && this.state.data.children && this.state.data.children !== null && Object.keys(this.state.data.children).length === 0;
  }

  render() {
    const {infinite, infiniteWidth, infiniteHeight, showSelected, toolTipPlacement, disabled, multipleSelect, expandable} = this.props;
    const selectedData = this.state.selectedData.map(item => <SelectedItem>{item.name}</SelectedItem>);
    return (<Container data-qa={this.props.testId}>
      {showSelected &&
        <Selected>{selectedData.length > 0 ? <span>Selected: {selectedData}</span> : ''}</Selected>}
      {this.checkEmpty() &&
        <p>There are no available data.</p>}
      {(!this.checkEmpty() && this.state.data && !disabled) &&
      <InputBox
        testId={this.props.testId}
        name={this.props.name}
        color={this.props.color}
        filter={this.state.data}
        toolTipPlacement={toolTipPlacement}
        checkFilter={(name, filter, checked) => {
          if (multipleSelect) {
            filter.checked = checked;
            if (checked) {
              flattenChildren(filter, true);
            }
            if (!checked) {
              flattenParent(filter, false);
              flattenChildren(filter, false);
            }
            this.update(filter.parent && filter.parent !== null ? filter.parent : filter, this.props.check);
          } else {
            // clear all
            const flatData = this.state.flatData;
            Object.keys(flatData).forEach(key => {
              flatData[key].checked = false;
            });

            // check filter
            filter.checked = true;
            flattenChildren(filter, true);
            this.update(filter.parent && filter.parent !== null ? filter.parent : filter, this.props.check);
          }
        }}
        updateFilter={(data) => {
          this.update(data);
          if (this.props.breadcrumClick) { this.props.breadcrumClick(data); }
        }}
        searchFilter={(value) => {
          let filter = this.state.data;
          const result = [];
          Object.keys(this.state.flatData).forEach((key) => {
            if (result.length < 15 && this.state.flatData[key].name.toLowerCase().indexOf(value.toLowerCase()) !== -1) { result.push(this.state.flatData[key]); }
          });
          while (filter.parent && filter.parent !== null) { filter = filter.parent; }
          filter.search_result = result;
          this.update(filter, this.props.search);
        }}
        resetSearch={() => {
          let filter = this.state.data;
          while (filter.parent && filter.parent !== null) { filter = filter.parent; }
          filter.search_result = [];
          this.update(filter, this.props.reset);
        }}
        uncheckAll={() => {
          let filter = this.state.data;
          const flatData = this.state.flatData;
          Object.keys(flatData).forEach(key => {
            flatData[key].checked = false;
          });
          while (filter.parent && filter.parent !== null) { filter = filter.parent; }
          this.update(filter, this.props.uncheckAll);
        }}
        clearall={this.props.showClearAll}
        search={this.props.showSearch}
        multipleSelect={this.props.multipleSelect}
        infinite={infinite}
        expandable={expandable}
        infiniteWidth={infiniteWidth}
        infiniteHeight={infiniteHeight}
      />}
    </Container>);
  }
}
