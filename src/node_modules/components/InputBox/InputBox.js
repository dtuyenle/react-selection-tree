import React, {Component} from 'react';
import PropTypes from 'prop-types';
import CheckBox from './../Style/CheckBox';
import Radio from './../Style/Radio';
import BinaryBreadCrum from './../BinaryBreadCrum';
import BinaryToolTip from './../BinaryToolTip';
import {List} from 'react-virtualized';

export default class InputBox extends Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    filter: PropTypes.object.isRequired,
    excludeSelect: PropTypes.array,
    toolTipPlacement: PropTypes.string,

    customName: PropTypes.string,
    customValue: PropTypes.bool,
    updateCustom: PropTypes.func,
    direction: PropTypes.string,

    updateFilter: PropTypes.func.isRequired,
    checkFilter: PropTypes.func.isRequired,
    searchFilter: PropTypes.func.isRequired,
    showAll: PropTypes.func,
    resetSearch: PropTypes.func.isRequired,
    uncheckAll: PropTypes.func.isRequired,
    search: PropTypes.bool,
    clearall: PropTypes.bool,
    infinite: PropTypes.bool,
    multipleSelect: PropTypes.bool,
  };

  static defaultProps = {
    name: '',
    search: false,
    clearall: true,
    direction: 'vertical',
    timer: null,
    excludeSelect: [],
    infinite: false,
    multipleSelect: true
  }

  constructor(props) {
    super(props);
    this.state = {
      breadcrums: [],
      search_value: '',
    };

    this.list = [];
    this.styles = require('./InputBox.scss');
  }

  componentWillReceiveProps(nextProps) {
    if (typeof nextProps.filter.search_result === 'undefined') {
      this.setState({ search_value: '' });
    }
  }

  getCheckBoxes() {
    const {filter, name, infinite} = this.props;
    const DATA = [];
    const DATASTAYFIRST = [];
    const keys = this.getOrderCheckBoxesByNameKey();
    if (this.state.search_value.trim().length < 3) {
      keys.map((key) => {
        if (!filter.children[key].stayfirst) {
          DATA.push(this.getCheckBox(filter.children[key], name));
        } else {
          DATASTAYFIRST.push(this.getCheckBox(filter.children[key], name));
        }
      });
    } else {
      if (filter.search_result && filter.search_result.length > 0) {
        filter.search_result.forEach((item) => {
          if (!item.stayfirst) {
            DATA.push(this.getCheckBox(item, name));
          } else {
            DATASTAYFIRST.push(this.getCheckBox(item, name));
          }
        });
      }
    }

    this.list = DATASTAYFIRST.concat(DATA);
    this.listElem = (<List
      ref="list"
      width={410}
      height={300}
      rowCount={this.list.length}
      rowHeight={30}
      rowRenderer={({
        key,
        index,
        style
      }) => {
        return (
          <div key={key} style={style}>
            {this.list[index]}
          </div>);
      }}
    />);

    return infinite ? this.listElem : DATASTAYFIRST.concat(DATA);
  }

  getCheckBox(checkboxNode, filterName) {
    const {multipleSelect, direction, excludeSelect, toolTipPlacement} = this.props;
    const id = checkboxNode.id + '_' + filterName.toLowerCase().split(' ').join('_');
    const name = filterName;
    const hoverText = this.getHoverText(checkboxNode);
    const defaultChecked = typeof checkboxNode.checked !== 'undefined' ? checkboxNode.checked : false;
    const style = direction === 'horizontal' ? {display: 'inline'} : {display: 'block'};

    const input = (<input
      defaultChecked={defaultChecked}
      ref={checkboxNode.id}
      key={checkboxNode.id}
      type={multipleSelect ? 'checkbox' : 'radio'}
      id={id}
      name={multipleSelect ? name + '_' + id : id}
      className={this.styles.binary_checkbox}
      onChange={this.handleCheckBoxClick.bind(this, checkboxNode)}
    />);

    const label = (<label htmlFor={id} title={hoverText} className={this.styles.binary_checkbox_label}>
      <BinaryToolTip
        key="binary_checkbox_tooltip"
        node={<span>{checkboxNode.name}</span>}
        data={hoverText.split('>').length > 1 && <p><strong>{hoverText}</strong></p>}
        placement={toolTipPlacement ? toolTipPlacement : 'left'}
      />
      {checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0 &&
      <span
        className="hint--top"
        data-hint="Go to next level"
        id={id + '_inner'}
        className={this.styles.binary_checkbox_label_level_down}
        onClick={this.handleInnerLevelClick.bind(this, checkboxNode)}
      >
        <i className="fa fa-chevron-down"></i>
      </span> }
    </label>);
    if (excludeSelect.indexOf(checkboxNode.id) !== -1) { return <span />; }
    return multipleSelect ? <CheckBox style={style}>{input}{label}</CheckBox> : <Radio style={style}>{input}{label}</Radio>;
  }

  getCustomInput() {
    const {customName, customValue} = this.props;
    const input = (<input
      defaultChecked={customValue}
      ref="custom"
      key={'custom_' + customValue}
      type="checkbox"
      id="custom"
      name="custom"
      onChange={() => {
        this.props.updateCustom();
      }}
    />);
    const label = (<label htmlFor="custom" title={customName} className={this.styles.binary_checkbox_label}>{customName}</label>);
    return <div key={customValue} className={this.styles.binary_checkbox_custom}><CheckBox>{input}{label}</CheckBox></div>;
  }

  getOrderCheckBoxesByNameKey() {
    const {filter} = this.props;
    const keysinorder = [];
    const keysObj = [];
    if (filter && filter.children && filter.children !== null) {
      Object.keys(filter.children).forEach((key) => { keysObj.push(filter.children[key]); });
    }
    keysObj.sort((item1, item2) => {
      let item1_ = '';
      let item2_ = '';
      if (item1.index && item2.index) {
        item1_ = item1.index;
        item2_ = item2.index;
      } else {
        item1_ = item1.name;
        item2_ = item2.name;
      }
      if (item1_ > item2_) {
        return 1;
      }
      if (item1_ < item2_) {
        return -1;
      }
      return 0;
    });
    keysObj.map( (item) => {
      keysinorder.push(item.id);
    });
    return keysinorder;
  }

  getCheckBoxBreadCrums() {
    const {filter} = this.props;
    const hierarchy = [filter];
    let checkbox = filter;

    while (checkbox && checkbox.parentId !== null && checkbox.parent) {
      hierarchy.push(checkbox.parent);
      checkbox = checkbox.parent;
    }
    return (<BinaryBreadCrum
      style={{fontSize: '12px'}}
      hierarchy={hierarchy.reverse()}
      handleBreadCrumClick={this.handleBreadCrumClick.bind(this)} />);
  }

  getHoverText(filter) {
    let filterData = Object.assign({}, filter);
    const hierarchy = [];
    const hover = [];
    while (filterData.parent) {
      hierarchy.push(filterData.parent);
      filterData = filterData.parent;
    }
    hierarchy.map((item) => {
      hover.push(item.name);
    });
    return hover.reverse().join(' > ');
  }

  getSearchInput() {
    const {filter} = this.props;
    return (
      <div className={this.styles.binary_filter_search}>
        <i className="fa fa-search" />
        <input
          onChange={this.search.bind(this)}
          type="text"
          placeholder="Search"
          ref="search"
          id={'binary_checkbox_search_' + filter.name}
          maxLength={80}
          value={this.state.search_value}
          addonBefore={<i className="fa fa-search" />}
        />
      </div>);
  }

  search(event) {
    if (event.target.value.trim().length === 0) {
      this.props.resetSearch();
    }
    if (event.target.value.length < 3) {
      this.setState({ search_value: event.target.value });
    } else {
      this.setState({ search_value: event.target.value }, () => {
        this.props.searchFilter(this.state.search_value);
      });
    }
  }

  handleBreadCrumClick(filters) {
    this.props.updateFilter(filters[filters.length - 1]);
  }

  handleInnerLevelClick(filter) {
    this.setState({
      search_value: ''
    }, () => {
      this.props.updateFilter(filter);
    });
  }

  uncheckAll() {
    this.setState({
      search_value: ''
    }, () => {
      this.props.uncheckAll();
      if (this.refs.list) { this.refs.list.forceUpdateGrid(); }
    });
  }

  handleCheckBoxClick(filter, event) {
    const {name, checkFilter} = this.props;
    if (checkFilter) {
      checkFilter(name, filter, event.target.checked);
    }
  }

  render() {
    const {filter, updateCustom, name, search, clearall, infinite} = this.props;
    const CHECKBOX_RENDER = this.getCheckBoxes();
    const BREADCRUMS_RENDER = this.getCheckBoxBreadCrums();

    return (
      <div>
        {filter && search &&
          this.getSearchInput()}
        {filter && updateCustom &&
          this.getCustomInput()}
        {filter &&
        <div className={this.styles.binary_filter_checkbox_breadcrum}>
          {BREADCRUMS_RENDER}
        </div>}
        {filter &&
        <div key={name.split(' ').join('')} style={infinite ? {overflow: 'inherit', maxHeight: 'none'} : {}} className={this.styles.binary_filter_checkbox_container}>
          {CHECKBOX_RENDER.length === 0 ? 'No Results Found !' : <div key={Math.random()}>{CHECKBOX_RENDER}</div>}
          {CHECKBOX_RENDER.length < 52 && this.props.showAll &&
            <p className={this.styles.show_all} onClick={this.props.showAll.bind(this)}>Show More</p> }
        </div>}
        {filter && clearall &&
        <div
          id={'binary_filter_clearall_' + name.split(' ').join('_').toLowerCase()}
          onClick={this.uncheckAll.bind(this)}
          className={this.styles.clear_all}>
          clear all
        </div>}
        {typeof filter === 'undefined' &&
          <p>No Data</p>}
      </div>
    );
  }
}
