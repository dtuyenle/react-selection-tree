export function convertObjectToArray(object, indexName = 'index') {
  const arr = Object.keys(object).map((key) => object[key]);
  arr.sort( (first, second) => {
    return second[indexName] - first[indexName];
  });
  return arr;
}

export function checkMobile() {
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    return true;
  }
  return false;
}

export function checkBrowser() {
  let browserName = '';
  // proudly stolen from http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
  // Opera 8.0+
  const isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
  if (isOpera) { browserName = 'opera'; }

  // Firefox 1.0+
  const isFirefox = typeof InstallTrigger !== 'undefined';
  if (isFirefox) { browserName = 'firefox'; }

  // At least Safari 3+: "[object HTMLElementConstructor]"
  const isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
  if (isSafari) { browserName = 'safari'; }

  // Internet Explorer 6-11
  const isIE = /* @cc_on!@ */false || !!document.documentMode;
  if (isIE) { browserName = 'ie'; }

  // Edge 20+
  const isEdge = !isIE && !!window.StyleMedia;
  if (isEdge) { browserName = 'ie'; }

  // Chrome 1+
  const isChrome = !!window.chrome && !!window.chrome.webstore;
  if (isChrome) { browserName = 'chrome'; }

  return browserName;
}

export function flattenChildren(node, checked, expanded, left) {
  const data = {[node.id]: node};
  const arr = [node];

  while (arr.length > 0) {
    let current = arr[0];
    arr.shift();
    if (typeof current.children !== 'undefined' && current.children !== null) {
      Object.keys(current.children).forEach((key) => {
        data[key] = current.children[key];
        data[key].expanded = typeof expanded !== 'undefined' ? expanded : data[key].expanded;
        data[key].left = typeof left !== 'undefined' ? left : data[key].left;
        data[key].checked = typeof checked !== 'undefined' ? checked : data[key].checked;
        data[key].parent = current;
        arr.push(current.children[key]);
      });
    }
  }
  return data;
}

export function flattenParent(node, checked, expanded, left) {
  let results = {};
  let currNode = node;
  while (currNode.parent && currNode.parent !== null) {
    currNode.expanded = typeof expanded !== 'undefined' ? expanded : currNode.expanded;
    currNode.left = typeof left !== 'undefined' ? left : currNode.left;
    currNode.checked = typeof checked !== 'undefined' ? checked : currNode.checked;
    results = Object.assign(results, currNode);
    currNode = currNode.parent;
  }
  return results;
}

export function flattenNode(node, checked, expanded = false, left = 0) {
  return Object.assign(flattenParent(node, checked, expanded, left), flattenChildren(node, checked, expanded, left));
}

export function copyTreeState(originalNode, copyNode) {
  const flatOriginalNode = flattenNode(originalNode);
  const flatCopyNode = flattenNode(copyNode);

  Object.keys(flatCopyNode).forEach((key) => {
    if (flatOriginalNode[key] && flatCopyNode[key]) {
      flatOriginalNode[key].checked = flatCopyNode[key].checked;
    }
  });
}

export function getNodeById(node, ids) {
  const nodes = flattenNode(node);
  return ids.map(id => nodes[id] ? nodes[id] : null);
}

export function getRootNode(node) {
  let rootNode = node;
  while(typeof rootNode.parentId !== 'undefined' && typeof rootNode.parent !== 'undefined' && rootNode.parent !== null) {
    rootNode = rootNode.parent;
  };
  return rootNode;
}

export function debounce(func, wait) {
  let timeout = null;
  return function(...args) {
    const context = this;
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(context, args), wait);
  };
}

export function throttle(func, wait) {
  let lastcall = 0;

  return function(...args) {
    const now = (new Date()).getTime();
    if (now - lastcall < wait) {
      return;
    }
    lastcall = now;
    return func(...args);
  };
}
