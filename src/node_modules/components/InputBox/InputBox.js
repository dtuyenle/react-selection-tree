import React, {Component} from 'react';
import PropTypes from 'prop-types';
import CheckBox from './../CheckBox';
import Radio from './../Radio';
import BreadCrum from './../BreadCrum';
import ToolTip from './../ToolTip';
import {List} from 'react-virtualized';
import styled from 'styled-components';

const CheckboxContainer = styled.div`
  padding: 12px;
  display: flex;
  max-height: 280px;
  border: 1px solid #CCC;
  overflow: auto;
  overflow-x: hidden;
  margin-left: 5px;

  span {
    margin: 0;
    font-weight: 400;
  }
`;

const CheckboxCustom = styled.div`
  font-size: 0.8em;
  margin: 1em 0;

  label:before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 8px;
    height: 8px;
    border: 1px solid #ddd;
    background: #fff;
  }
`;

const CheckboxLabel = styled.label`
  font-size: 1em;
`;

const CheckboxLabelLevelDown = styled.i`
  color: #6090C3;
  margin-left: 5px;
  font-size: 1em;
  margin-top: 2px;
`;

const Search = styled.div`
  display: flex;
  &:after {
    content: "";
    display: table;
    clear: both;
  }

  img {
    float: left;
    background: #EEE;
    color: #666;
    border: 1px #CCC solid;
    border-right: none;
    padding: 0.68em;
    width: 15px;
    height: 15px;
  }

  input {
    padding: 0.5em;
    border-radius: 0px;
    border: 1px #CCC solid;
    flex-grow: 1;
  }
`;

const ClearAll = styled.div`
  margin-top: 10px;
  margin-left: 10px;
  color: #6090C3;
  cursor: pointer;
  width: 60px;
`;

const ShowAll = styled.div`
  color: #6090C3;
  margin: 10px 8px 0 8px;
`;



export default class InputBox extends Component {
  static propTypes = {
    name: PropTypes.string.isRequired,
    filter: PropTypes.object.isRequired,
    excludeSelect: PropTypes.array,
    toolTipPlacement: PropTypes.string,

    customName: PropTypes.string,
    customValue: PropTypes.bool,
    updateCustom: PropTypes.func,
    direction: PropTypes.string,

    updateFilter: PropTypes.func.isRequired,
    checkFilter: PropTypes.func.isRequired,
    searchFilter: PropTypes.func.isRequired,
    showAll: PropTypes.func,
    resetSearch: PropTypes.func.isRequired,
    uncheckAll: PropTypes.func.isRequired,
    search: PropTypes.bool,
    clearall: PropTypes.bool,
    infinite: PropTypes.bool,
    multipleSelect: PropTypes.bool,
  };

  static defaultProps = {
    name: '',
    search: false,
    clearall: true,
    direction: 'vertical',
    timer: null,
    excludeSelect: [],
    infinite: false,
    multipleSelect: true
  }

  constructor(props) {
    super(props);
    this.state = {
      breadcrums: [],
      search_value: '',
    };

    this.list = [];
  }

  componentWillReceiveProps(nextProps) {
    if (typeof nextProps.filter.search_result === 'undefined') {
      this.setState({ search_value: '' });
    }
  }

  getCheckBoxes() {
    const {filter, name, infinite} = this.props;
    const DATA = [];
    const DATASTAYFIRST = [];
    const keys = this.getOrderCheckBoxesByNameKey();
    if (this.state.search_value.trim().length < 3) {
      keys.forEach((key) => {
        if (!filter.children[key].stayfirst) {
          DATA.push(this.getCheckBox(filter.children[key], name));
        } else {
          DATASTAYFIRST.push(this.getCheckBox(filter.children[key], name));
        }
      });
    } else {
      if (filter.search_result && filter.search_result.length > 0) {
        filter.search_result.forEach((item) => {
          if (!item.stayfirst) {
            DATA.push(this.getCheckBox(item, name));
          } else {
            DATASTAYFIRST.push(this.getCheckBox(item, name));
          }
        });
      }
    }

    this.list = DATASTAYFIRST.concat(DATA);
    this.listElem = (<List
      ref="list"
      width={410}
      height={300}
      rowCount={this.list.length}
      rowHeight={30}
      rowRenderer={({
        key,
        index,
        style
      }) => {
        return (
          <div key={key} style={style}>
            {this.list[index]}
          </div>);
      }}
    />);

    return infinite ? this.listElem : DATASTAYFIRST.concat(DATA);
  }

  getCheckBox(checkboxNode, filterName) {
    const {multipleSelect, direction, excludeSelect, toolTipPlacement} = this.props;
    const id = checkboxNode.id + '_' + filterName.toLowerCase().split(' ').join('_');
    const name = filterName;
    const hoverText = this.getHoverText(checkboxNode);
    const defaultChecked = typeof checkboxNode.checked !== 'undefined' ? checkboxNode.checked : false;
    const style = direction === 'horizontal' ? {display: 'inline'} : {display: 'block'};

    const input = (<input
      defaultChecked={defaultChecked}
      ref={checkboxNode.id}
      key={checkboxNode.id}
      type={multipleSelect ? 'checkbox' : 'radio'}
      id={id}
      name={multipleSelect ? name + '_' + id : id}
      onChange={this.handleCheckBoxClick.bind(this, checkboxNode)}
    />);

    const label = (<CheckboxLabel htmlFor={id} title={hoverText}>
      <ToolTip
        key="binary_checkbox_tooltip"
        node={<span>{checkboxNode.name}</span>}
        data={hoverText.split('>').length > 1 && <p><strong>{hoverText}</strong></p>}
        placement={toolTipPlacement ? toolTipPlacement : 'left'}
      />
      {checkboxNode.children && checkboxNode.children !== null && Object.keys(checkboxNode.children).length !== 0 &&
      <span
        data-hint="Go to next level"
        id={id + '_inner'}
        className="hint--top"
        onClick={this.handleInnerLevelClick.bind(this, checkboxNode)}
      >
        <CheckboxLabelLevelDown className="fa fa-chevron-down"></CheckboxLabelLevelDown>
      </span> }
    </CheckboxLabel>);
    if (excludeSelect.indexOf(checkboxNode.id) !== -1) { return <span />; }
    return multipleSelect ? <CheckBox style={style}>{input}{label}</CheckBox> : <Radio style={style}>{input}{label}</Radio>;
  }

  getCustomInput() {
    const {customName, customValue} = this.props;
    const input = (<input
      defaultChecked={customValue}
      ref="custom"
      key={'custom_' + customValue}
      type="checkbox"
      id="custom"
      name="custom"
      onChange={() => {
        this.props.updateCustom();
      }}
    />);
    const label = (<CheckboxLabel htmlFor="custom" title={customName}>{customName}</CheckboxLabel>);
    return <div key={customValue}><CheckboxCustom><CheckBox>{input}{label}</CheckBox></CheckboxCustom></div>;
  }

  getOrderCheckBoxesByNameKey() {
    const {filter} = this.props;
    const keysinorder = [];
    const keysObj = [];
    if (filter && filter.children && filter.children !== null) {
      Object.keys(filter.children).forEach((key) => { keysObj.push(filter.children[key]); });
    }
    keysObj.sort((item1, item2) => {
      let item1_ = '';
      let item2_ = '';
      if (item1.index && item2.index) {
        item1_ = item1.index;
        item2_ = item2.index;
      } else {
        item1_ = item1.name;
        item2_ = item2.name;
      }
      if (item1_ > item2_) {
        return 1;
      }
      if (item1_ < item2_) {
        return -1;
      }
      return 0;
    });
    keysObj.forEach( (item) => {
      keysinorder.push(item.id);
    });
    return keysinorder;
  }

  getCheckBoxBreadCrums() {
    const {filter} = this.props;
    const hierarchy = [filter];
    let checkbox = filter;

    while (checkbox && checkbox.parentId !== null && checkbox.parent) {
      hierarchy.push(checkbox.parent);
      checkbox = checkbox.parent;
    }
    return (<BreadCrum
      style={{fontSize: '12px'}}
      hierarchy={hierarchy.reverse()}
      handleBreadCrumClick={this.handleBreadCrumClick.bind(this)} />);
  }

  getHoverText(filter) {
    let filterData = Object.assign({}, filter);
    const hierarchy = [];
    const hover = [];
    while (filterData.parent) {
      hierarchy.push(filterData.parent);
      filterData = filterData.parent;
    }
    hierarchy.forEach((item) => {
      hover.push(item.name);
    });
    return hover.reverse().join(' > ');
  }

  getSearchInput() {
    const {filter} = this.props;
    return (
      <Search>
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAARhSURBVGhD1ZpbyGZTGMc/jHNyisjZjNOFQyPcTCZFIYQL05waJHeomZrBpChuRk2GQo6RUrhwmCYulZwPGcwNzTCOQ85R5PT7YdXTau3x7r3X/mb716/eb7/f+6y19l7rOb3vVA8dCBfCtXAHPAD3wRpYBufC3jBKHQw3wDvw5wT8Dq/A1bAvbHO5gPvhFyhNeBJ+hFthL5h2bQdXgZMoTU5+hU3wOrwJm+E3KP2vfAGXwLRpD3gGSpN5F26BU2FHyLUznAG3wUYo2bgbSp+tqv3AO5wP7h0/E9rIpzoP3ofc3jrYDQbRnvAaxAF/hkvBSXXVTqCHy7fdU7ADVJUTfRriQJ/AyVBLZ8N3EMe4HarqGogDfAyHQG2dAHExf8D5UEW62OidfoJTYChdAHGbfQS7Q28ZJ5JRuQyG1s0Qx7wOesmnEYPdG9DnYE8qPdankMb9CnaFzloJyZi0dbF9dAXEsedDZxngkqH3vDCNMihugTS+7riTDoBkRIzYUdvDif+8HEx3QRr/e5gBrWUqHhdyGkSZF5lvDamLIc7hJGgto20yYAKY3w3zrfwp1dbhEBdiStNaFkXJwAdeCHJb+agf/fuv4eQ4MaYshdZ6EJKBt7wQpFv2+tfQad+20LeQ5nGjF9oqBsK3vRB0PKT3TMuHVExZOgVGa+xk4EMvBEWP9qQXBpJP23wrjXU5tJb7MRlwn+4CSabXMeLPgSF0NKQx5DxoLbsd0Ui+hZ6D9N56GKIQWghxDrOgtWzZ2O1IRixPo66EOMgTUDsPewiSfWv+znoVkiEbCXGi1t+enfS+3Au16m2fsC4+2bY/1ln2neJE8y7HRRAPozwP+0NfrYBo1wqys2yexaLKwJjf8ZsgDijeSTPnrgXRPhDjhwlr7227CuIkvVO5lkM8TwkDpvvcnOkgmHTb3QPRTie3m8sOYEyndcXnQK7TwTZonECO29C7uxia7nDuRGw/VcsePBvRuNG2lIk6ubmwGl4EPc2XsAEegSWwtUrvLIjxyddmEVVlBzAu5gfoFKAa5JMwy45j2KirLhtpayEO5LnwsPepp3Uo+U2K2IjQvlu32tPRt5f6vp+BNXabGKItnUT0Tk3Y0Uyv3bKHQW958Ewo8/ghOoU7wfhyBFhPJPm5o8C042HIu4rihJ/NrpWw13UkVJHnQ4OlgRJuvW/+pfR+5AUwSdRh2Cot/U+k6mIMeNeDnqk02CRYtC2C+PTyPK8JveJMqCYP4wKwNtGblQaNmLeZlzX1yYxTpc+VsA/tlq0uz4JtIhsFfvlpeWplZ6vV7TjJHZwNpUk34TcDbstR6iUoTboJW6zHwOh0KPyXM8kxDBwLo5NeyQNdmnQTn8NxMDp5pjzQpUk34WJsWY1O1uptF/M4jFK6WL1TadIlDMKjlS42fgG0NVz0qKWL1TuVJh+xsh29dLEe6NIC5GXo9VXddEoX6+9XSovwxw3/K9nQeAysaTwT/spoiI7nttbU1F8ecld/HmfjEQAAAABJRU5ErkJggg==" />
        <input
          onChange={this.search.bind(this)}
          type="text"
          placeholder="Search"
          ref="search"
          id={'binary_checkbox_search_' + filter.name}
          maxLength={80}
          value={this.state.search_value}
          addonBefore={<i className="fa fa-search" />}
        />
      </Search>);
  }

  search(event) {
    if (event.target.value.trim().length === 0) {
      this.props.resetSearch();
    }
    if (event.target.value.length < 3) {
      this.setState({ search_value: event.target.value });
    } else {
      this.setState({ search_value: event.target.value }, () => {
        this.props.searchFilter(this.state.search_value);
      });
    }
  }

  handleBreadCrumClick(filters) {
    this.props.updateFilter(filters[filters.length - 1]);
  }

  handleInnerLevelClick(filter) {
    this.setState({
      search_value: ''
    }, () => {
      this.props.updateFilter(filter);
    });
  }

  uncheckAll() {
    this.setState({
      search_value: ''
    }, () => {
      this.props.uncheckAll();
      if (this.refs.list) { this.refs.list.forceUpdateGrid(); }
    });
  }

  handleCheckBoxClick(filter, event) {
    const {name, checkFilter} = this.props;
    if (checkFilter) {
      checkFilter(name, filter, event.target.checked);
    }
  }

  render() {
    const {filter, updateCustom, name, search, clearall, infinite} = this.props;
    const CHECKBOX_RENDER = this.getCheckBoxes();
    const BREADCRUMS_RENDER = this.getCheckBoxBreadCrums();

    return (
      <div>
        {filter && search &&
          this.getSearchInput()}
        {filter && updateCustom &&
          this.getCustomInput()}
        {filter &&
        <div>
          {BREADCRUMS_RENDER}
        </div>}
        {filter &&
        <CheckboxContainer key={name.split(' ').join('')} style={infinite ? {overflow: 'inherit', maxHeight: 'none'} : {}}>
          {CHECKBOX_RENDER.length === 0 ? 'No Results Found !' : <div key={Math.random()}>{CHECKBOX_RENDER}</div>}
          {CHECKBOX_RENDER.length < 52 && this.props.showAll &&
            <ShowAll onClick={this.props.showAll.bind(this)}>Show More</ShowAll> }
        </CheckboxContainer>}
        {filter && clearall &&
        <ClearAll
          id={'binary_filter_clearall_' + name.split(' ').join('_').toLowerCase()}
          onClick={this.uncheckAll.bind(this)}>
          clear all
        </ClearAll>}
        {typeof filter === 'undefined' &&
          <p>No Data</p>}
      </div>
    );
  }
}
