import React, {Component} from 'react';
import PropTypes from 'prop-types';
import InputBox from './../InputBox';
import {flattenParent, flattenChildren, flattenNode, copyTreeState} from './util';
import {merge} from 'lodash';
import styled from 'styled-components';

const Container = styled.div`
  width: 100%;
`;

export default class ReactSelectionTree extends Component {

  static propTypes = {
    /** name of the selection tree must be unique */
    name: PropTypes.string.isRequired,
    /** data tree */
    data: PropTypes.object.isRequired,
    /** array of node id that don't want to include */
    excludeSelect: PropTypes.array,
    /** node color override */
    color: PropTypes.string,
    /** select color override */
    selectcolor: PropTypes.string,
    /** breadcrum on click callback */
    breadcrumClick: PropTypes.func.isRequired,
    /** node on click callback */
    check: PropTypes.func.isRequired,
    /** on search callback */
    search: PropTypes.func.isRequired,
    /** reset callback */
    reset: PropTypes.func.isRequired,
    /** uncheck all callback */
    uncheckAll: PropTypes.func.isRequired,
    /** show search toggle */
    showSearch: PropTypes.bool,
    /** show clear all toggle */
    showClearAll: PropTypes.bool,
    /** if true react-virtualized kick in (only use if you have more than say 500 to 1000 nodes) */
    infinite: PropTypes.bool,
    /** virtualize width container */
    infiniteWidth: PropTypes.number,
    /** virtualize height container */
    infiniteHeight: PropTypes.number,
    /** if true check box if false radio box */
    multipleSelect: PropTypes.bool,
    /** if true you can expand as a tree instead of going into nested level */
    expandable: PropTypes.bool,
  };

  static defaultProps = {
    name: '',
    color: '#6090C3',
    selectcolor: '#FF8800',
    search: true,
    expandable: false
  };

  constructor(props) {
    super(props);
    this.state = {
      data: false,
      originalData: false,
      flatData: false
    }
  }

  componentDidMount() {
    this.load();
  }

  load() {
    const data = this.props.data;
    const flatData = flattenNode(data, false);
    this.setState({
      data: data,
      flatData: flatData,
      originalData: merge({}, this.state.data)
    });
  }

  reset() {
    const flatData = this.state.flatData;
    Object.keys(flatData).forEach(key => {
      if (flatData[key] && typeof flatData[key].checked !== 'undefined') {
        flatData[key].checked = false;
      }
    });
    let rootData = this.state.data;
    while (rootData.parent && rootData.parent !== null) { rootData = rootData.parent; }
    rootData.search_result = undefined;
    this.setState({
      data: Object.assign({}, rootData),
      flatData: Object.assign({}, this.state.flatData)
    });
  }

  update(data, callback) {
    this.setState({
      data: Object.assign({}, data),
      flatData: Object.assign({}, this.state.flatData)
    }, () => {
      if (callback) { callback(data, this.state.flatData); }
    })
  }

  updateOriginalFromData() {
    copyTreeState(this.state.originalData, this.state.data);
    this.setState({
      originalData: Object.assign({}, this.state.originalData)
    });
  }

  updateDataFromOriginal() {
    copyTreeState(this.state.data, this.state.originalData);
    const rootNode = Object.assign({}, this.state.data);
    this.setState({
      data: rootNode,
      flatData: flattenNode(rootNode)
    });
  }

  checkEmpty() {
    return this.state.data && this.state.data !== null && this.state.data.children && this.state.data.children !== null && Object.keys(this.state.data.children).length === 0;
  }

  render() {
    const {expandable, infinite, infiniteWidth, infiniteHeight} = this.props;
    return (
      <Container>
        {this.checkEmpty() &&
          <p>There are no available data.</p>}
        {!this.checkEmpty() && this.state.data &&
        <InputBox
          name={this.props.name}
          color={this.props.color}
          filter={this.state.data}
          checkFilter={(name, filter, checked) => {
            filter.checked = checked;
            if (checked) {
              flattenChildren(filter, true);
            }
            if (!checked) {
              flattenParent(filter, false);
              flattenChildren(filter, false);
            }
            this.update(filter.parent && filter.parent !== null ? filter.parent : filter, this.props.check);
          }}
          updateFilter={(data) => {
            this.update(data);
            if (this.props.breadcrumClick) { this.props.breadcrumClick(data); }
          }}
          searchFilter={(value) => {
            let filter = this.state.data;
            const result = [];
            Object.keys(this.state.flatData).forEach((key) => {
              if (result.length < 15 && this.state.flatData[key].name.toLowerCase().indexOf(value.toLowerCase()) !== -1) { result.push(this.state.flatData[key]); }
            });
            while (filter.parent && filter.parent !== null) { filter = this.state.data.parent; }
            filter.search_result = result;
            this.update(filter, this.props.search);
          }}
          resetSearch={() => {
            let filter = this.state.data;
            while (filter.parent && filter.parent !== null) { filter = this.state.data.parent; }
            filter.search_result = [];
            this.update(filter, this.props.reset);
          }}
          uncheckAll={() => {
            let filter = this.state.data;
            const flatData = this.state.flatData;
            Object.keys(flatData).forEach(key => {
              flatData[key].checked = false;
            });
            while (filter.parent && filter.parent !== null) { filter = this.state.data.parent; }
            this.update(filter, this.props.uncheckAll);
          }}
          clearall={this.props.showClearAll}
          search={this.props.showSearch}
          multipleSelect={this.props.multipleSelect}
          expandable={expandable}
          infinite={infinite}
          infiniteWidth={infiniteWidth}
          infiniteHeight={infiniteHeight}
        />}
      </Container>);
  }
}
