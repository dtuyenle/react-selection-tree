/* eslint-disable */
// flatten children nodes
export function flattenChildren(node, checked) {
  const data = {[node.id]: node};
  const arr = [node];

  while (arr.length > 0) {
    let current = arr[0];
    arr.shift();
    if (typeof current.children !== 'undefined' && current.children !== null) {
      Object.keys(current.children).forEach((key) => {
        data[key] = current.children[key];
        data[key].checked = typeof checked !== 'undefined' ? checked : data[key].checked;
        data[key].parent = current;
        arr.push(current.children[key]);
      });
    }
  }
  return data;
}

/* eslint-enable */

// flatten parent nodes
export function flattenParent(node, checked) {
  let results = {};
  let currNode = node;
  while (currNode.parent && currNode.parent !== null) {
    currNode.checked = typeof checked !== 'undefined' ? checked : currNode.checked;
    results = Object.assign(results, currNode);
    currNode = currNode.parent;
  }
  return results;
}

// flatten a tree
export function flattenNode(node, checked) {
  return Object.assign(flattenParent(node, checked), flattenChildren(node, checked));
}

// copy state from one tree to another
export function copyTreeState(originalNode, copyNode) {
  const flatOriginalNode = flattenNode(originalNode);
  const flatCopyNode = flattenNode(copyNode);

  Object.keys(flatCopyNode).forEach((key) => {
    if (flatOriginalNode[key] && flatCopyNode[key]) {
      flatOriginalNode[key].checked = flatCopyNode[key].checked;
    }
  });
}

// get a node by id
export function getNodeById(node, ids) {
  const nodes = flattenNode(node);
  return ids.map(id => nodes[id] ? nodes[id] : null);
}
